# Небольшой ликбез

**Скрипты.**

Скрипты - сценарии, выполняемые игрой. Движок игры распознаёт различные события (например, OnHit() - актёра стукнули). Скрипты можно привязывать к различным вещам, в том числе и к событиям. События характеризуются частотой, а функции Папируса - скоростью выполнения (об этом можно почитать [на Реддите](https://www.reddit.com/r/skyrimmods/comments/4omjly/a_few_script_execution_speed_psas/) и [на Нексусе](http://www.nexusmods.com/skyrim/mods/18825/)). Различные их комбинации могут повлиять на обработку скриптов. Например, событие OnHit() очень часто происходит во время кулачной драки, поэтому при привязке к нему скрипта движок может быть перегружен в момент драки. Событие OnUpdate() может быть очень жрущим, т.к. вызывается каждые N секунд и может содержать в себе "долгие" функции. Если это событие не успеет выполниться (налезет на следующее такое же) или не будет подчищено с помощью UnregisterForUpdate(), то работа Папируса замедлится, а сохранение раздуется. То, с какими скриптами справится твоя сборка, а с какими - нет, зависит от твоих модов и железа. Ты можешь навернуть хренову гору модов со скриптами, выполняющимися только при определённых условиях и содержащими быстрые функции, и твоя сборка не будет иметь задержек/переполнений стека, а можешь повесить игру одним-единственным модом, скрипт которого плохо написан/часто выполняет очень долгие функции.

------

**Память.**

Многие новички, установив Скайрим, думают, что он будет работать нормально. **ЭТО НЕ ТАК**. Беседка запилила очень странный механизм выделения памяти - два блока по 256 мегабайт, заполняющиеся с разной скоростью. Проблема в том, что первый блок может очень быстро переполниться, что приведёт к крашу. SKSE Memory Patch пытается решить эту проблему путём увеличения размера блоков. Это может отложить краш (в том числе насовсем), но не решает проблему. В Crash Fixes есть опция, позволяющая использовать malloc для выделения памяти. Данная фича избавляет игру от гадкого беседкоподхода, но есть риск deadlock'а (взаимной блокировки). Crash Fixes достаточно нов, но уже очень хорош в плане подхода и функционала. Касательно deadlock'ов - сам словил только 2 раза за 10 часов игры (учти, что у меня 8 гигов RAM и без Скайрима они уже используются на 30%, т.к. постоянно активен браузер).

Другая проблема Скайрима - VRAM. Скайрим - 32-битное приложение, поэтому без шаманств больше 3,1 гига он не увидит. ENB, дабы его графические фичи не убивали игру, позволяет использовать больше VRAM и содержит некоторые фиксы (если отключить все графические примочки, то оставшееся будет называться ENBoost). Одна из распространённых ошибок - выставление параметра VideoMemorySizeMb на меньшее значение, чем 3,1 гигабайта. Внимательно читай гайды по настройке либо используй AutodetectVideoMemorySize=true.

**Итог: без грамотной настройки внешних хаков в Скайрим нормально поиграть не выйдет, и никто, кроме тебя, эти хаки не настроит.**

------

**Текстуры, модели и плагины.**

Меш (mesh) - 3D-моделька, на неё натягиваются текстуры. Это делается прописыванием пути текстур в nif-файле модели. Чтобы понять, как всё это взаимосвязано, приведу пример:

У тебя есть мод, добавляющий новую ложку (в МО он будет отображаться как Spoon). Он состоит из плагина Spoon.esp, а также папкок Meshes и Textures. В Meshes лежит файл модели - spoon.nif, который ссылается на текстуры spoon.dds и другие, лежащие в Textures. В Spoon.esp есть запись, ссылающаяся на spoon.nif. Допустим, ты хочешь поставить ретекстур этой ложки (в МО это будет мод Spoon Retexture). Самый простой способ - поставить новую текстуру с таким же названием, т.е. spoon.dds (МО при этом покажет частичную перезапись мода Spoon). Вдруг ты решил, что тебе нужен не ретекстур, а реплейсер этой ложки. Ты ставишь через МО мод Spoon Replacer, содержащий spoon.nif. Далее возможны варианты: меш использует те же пути к текстурам или меш ссылается на другие текстуры (например, на spoon_new.dds). Во втором случае с реплейсером также будет идти новая текстура.

Теперь про реплейсеры. Принцип реплейсеров, не содержащих esp, ты уже понял из описанного выше. Теперь рассмотрим другой случай.

В игре есть объекты А, Б и В. Они используют одну и ту же модель (допустим, 1.nif). Ты устанавливаешь мод, который изменяет эти объекты и выдаёт им новые модели - А по-прежнему использует 1.nif, но Б стал использовать 2.nif, а В - 3.nif. Как это делается? В плагине изменяются объекты Б и В - им прописываются другие пути к модели. Эти новые модели могут ссылаться как на старые текстуры, так и на новые.

------

|[*Назад к оглавлению*](../01_Оглавление.md)|
|:---:|
